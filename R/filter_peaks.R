#' Filter a pspecterlib peak_data object
#'
#' @description For best results in the IsoMatchMS algorithm, it's best to filter
#'     by a specific M/Z range and a noise threshold.
#'
#' @param PeakData A peak_data object generated by get_peak_data (from mzML or raw),
#'     or make_peak_data in pspecterlib. Required.
#' @param MZRange A range of MZ values to filter the data by.
#'     It is highly recommended that users visualize the spectra first to determine
#'     a reasonable cutoff range. Required.
#' @param NoiseFilter An abundance (every peak is scaled to the largest peak) cutoff
#'     for peaks. A reasonable value should be in the 0.01 - 5.0% range. Default is 1%.
#'
#' @returns A peak_data object that has been filtered.
#'
#' @examples
#' \dontrun{
#'
#' # Download an example file
#' tmpdir <- tempdir()
#' TopDownFile <- "https://raw.githubusercontent.com/EMSL-Computing/PSpecteR/master/pspecter_container/TestFiles/TopDown/TopDown.mzML"
#' download.file(TopDownFile, file.path(tmpdir, tail(unlist(strsplit(TopDownFile, "/")), 1)))
#'
#' # Read with pspecterlib (mzR on the backend)
#' TD_ScanMetadata <- pspecterlib::get_scan_metadata(MSPath = file.path(tmpdir, "TopDown.mzML"))
#'
#' # Extract MS1 peak data
#' PeakData <- pspecterlib::get_peak_data(TD_ScanMetadata, 5684)
#'
#' # Plot peak data
#' pspecterlib::annotated_spectrum_plot(PeakData = PeakData, Interactive = TRUE)
#'
#' # Cutoff at 2.5% and 97.5% percentile ranges
#' quantile(PeakData$`M/Z`, c(0.025, 0.975))
#'
#' # Set a cutoff of MZ range
#' filter_peaks(
#'    PeakData = PeakData,
#'    MZRange = c(640, 1550),
#'    NoiseFilter = 2.5
#' )
#'
#' }
#'
#' @export
filter_peaks <- function(PeakData,
                         MZRange,
                         NoiseFilter = 1) {

  ##################
  ## CHECK INPUTS ##
  ##################

  # PeakData should be a peak_data object
  if (!inherits(PeakData, "peak_data")) {
    stop("PeakData should be a peak_data object from the pspecterlib get_peak_data or make_peak_data functions.")
  }

  # MZRange should be a numeric of length 2
  if (!is.numeric(MZRange) | length(unique(MZRange)) <= 1) {
    stop("MZRange should be a numeric with more than 1 unique value.")
  }
  if (length(MZRange) > 2) {
    message("More than 2 values found in MZRange. Only the min and max will be used.")
  }

  # NoiseFilter should be between 0 and 100
  if (!is.numeric(NoiseFilter) || NoiseFilter < 0 | NoiseFilter > 100) {
    stop("NoiseFilter should be a numeric between 0 and 100, inclusive.")
  }

  ##################
  ## Filter Peaks ##
  ##################

  # Change class for filtering
  class(PeakData) <- c("data.table", "data.frame")

  # Filter by MZ Range and Minimum Abundance
  PeakData <- PeakData %>%
    dplyr::filter(`M/Z` >= min(MZRange) & `M/Z` <= max(MZRange)) %>%
    dplyr::filter(Abundance >= NoiseFilter)

  ###################
  ## RETURN OBJECT ##
  ###################

  # Add attributes
  attr(PeakData, "pspecter")$MinimumAbundance <- NoiseFilter
  attr(PeakData, "pspecter")$MinimumMZ <- min(MZRange)
  attr(PeakData, "pspecter")$MaximumMZ <- max(MZRange)
  attr(PeakData, "pspecter")$NumberPeaksPostFilter <- nrow(PeakData)
  attr(PeakData, "pspecter")$PercentagePeaksRemain <-  paste0(round( attr(PeakData, "pspecter")$NumberPeaksPostFilter /  attr(PeakData, "pspecter")$TotalNumberPeaks * 100, digits = 2), "%")

  # Fix class
  class(PeakData) <- c(class(PeakData), "peak_data")

  # Return PeakData
  return(PeakData)

}
